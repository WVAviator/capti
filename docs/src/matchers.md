# Matchers

Matchers are what make Capti so flexible when writing tests for HTTP endpoints. Often we don't know exactly what we're going to get back from the server (e.g. a unique ID value generated by the database). Using matchers, we can verify that the the response returns any value, or returns value to follows some sort of pattern or structure.

Here is an example test that makes heavy use of various matchers:

```yaml
tests:
  - test: "get hello"
    description: "hello endpoint responds with some type of greeting"
    request:
      method: GET
      url: "http://localhost:3000/hello"
    expect:
      status: 2xx # match any 200 level status code
      headers:
        Content-Type: application/json # exact match
      body:
        message: $regex /[Hh]ello/ # match based on regex
        currentTime: $exists # match anything as long as it is present
```

## Format

Matchers are always a keyword prefixed with a `$` symbol, and followed by any number of arguments. The arguments, in some case, are also valid as a matcher themselves, thus some matchers can be nested. Here are some examples:

```
# this matcher takes no arguments
$exists 

# this matcher takes one argument - a regex string used to match the response
$regex /[Hh]ello/ 

# this matcher checks whether the array at this position contains an object with the property "id"
$includes { "id": $exists } 
```
